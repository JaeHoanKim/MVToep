#' Multivariate normal sampling from RBF covarinace kernel with regular grids
#'
#' @param n a
#' @param gridpoints b
#' @param l c
#' @param mu d
#' @param tau e
#'
#' @return f
#' @export
#'
#' @examples
#' rmvRBF(100, c(0:20)/20, l = 0.1, tau = 1)
rmvRBF = function(n, gridpoints, l, mu = rep(0, length(gridpoints)), tau = 1){
N = length(gridpoints)
grid_regular_check(gridpoints)
embed_result = nnd.C.RBF(gridpoints, m = min_m(gridpoints), l)
cj = embed_result$cj
m = embed_result$m
lambda = embed_result$eigval
out = matrix(0, n, m)
for (k in 1:n){
vec = rep(0, m)
vec[1] = sqrt(lambda[1]) * rnorm(1) / sqrt(m)
vec[(m / 2) + 1] = sqrt(lambda[(m / 2) + 1]) * rnorm(1) / sqrt(m)
i=sqrt(as.complex(-1))
for(j in 2:(m/2)){
uj = rnorm(1); vj = rnorm(1)
vec[j] = (sqrt(lambda[j]) * (uj + i * vj)) / (sqrt(2 * m))
vec[m + 2 - j] = (sqrt(lambda[j]) * (uj - i * vj)) / (sqrt(2 * m))
}
out[k, ] = Re(fft(vec))
}
out = out[, 1:N] * tau
out = out + matrix(mu, n, N, byrow = T)
return(out)
}
nnd.C.Mat(c(0:50)/50, m = 128, rho = 3, nu = 1)
test_that("error check for ill-conditioned matrix",{
expect_error(rmvRBF(10, c(0:30)/30, l=3), "It seems that adequate circular matrix is not found. Try smaller l.")
expect_error(rmvMat(10, c(0:50)/50, rho = 3, nu = 1), "It seems that adequate circular matrix is not found. Try smaller l.")
})
test_that("error in nnd function", {
expect_error(nnd.C.RBF(c(0:30)/30, m = 64, l = 3), "It seems that adequate circular matrix is not found. Try smaller l.")
expect_error(nnd.C.Mat(c(0:50)/50, m = 128, rho = 3, nu = 1), "It seems that adequate circular matrix is not found. Try smaller l.")
})
rmvToep(5, Sigma1)
Sigma2 = matrix(c(1, 0.99, 0.97, 0.94, 0.89,
0.99, 1, 0.99, 0.97, 0.94,
0.97, 0.99, 1, 0.99, 0.97,
0.94, 0.97, 0.99, 1, 0.99,
0.89, 0.94, 0.97, 0.99, 1), 5, 5)
rmvToep(5, Sigma2)
Sigma1 = matrix(c(2, 1, 0,
1, 2, 1,
0, 1.001, 2,
1, 2, 3), 3, 4)
test_that("Compatibility check", {
expect_error(rmvToep(5, Sigma1), "Sigma should be a square matrix!")
expect_error(rmvToep(5, Sigma2), "Sigma is ill-conditioned or not Positive definite; try rmvMat or rmvRBF if applicable.")
expect_error(grid_regular_check(grid1), "gridpoints should be regular!")
})
grid1 = c(0:8)/8
grid1[3] = grid1[3] + 0.001
test_that("Compatibility check", {
expect_error(rmvToep(5, Sigma1), "Sigma should be a square matrix!")
expect_error(rmvToep(5, Sigma2), "Sigma is ill-conditioned or not Positive definite; try rmvMat or rmvRBF if applicable.")
expect_error(grid_regular_check(grid1), "gridpoints should be regular!")
})
Sigma3 = matrix(c(1, 0.1, 0, 0, 0,
0.1, 1, 0.1, 0, 0,
0, 0.1, 1, 0.1, 0,
0, 0, 0.1, 1, 0.1,
0, 0, 0, 0.1, 1), 5, 5)
Sigma3
Sigma = Sigma3
# lambda = eigen(Sigma)$values
Sigma_vec = Sigma[1, ] # first row of Sigma, which contains all the values in Sigma
C_vec = c(Sigma_vec[1:N], Sigma_vec[N:1])
lambda = Re(fft(C_vec))
N = 5
# lambda = eigen(Sigma)$values
Sigma_vec = Sigma[1, ] # first row of Sigma, which contains all the values in Sigma
C_vec = c(Sigma_vec[1:N], Sigma_vec[N:1])
lambda = Re(fft(C_vec))
if (min(lambda) < 0){
stop("Sigma is ill-conditioned or not Positive definite; try rmvMat or rmvRBF if applicable.")
} else{
m = 2*N
out = matrix(0, n, m)
for (k in 1:n){
vec = rep(0, m)
vec[1] = sqrt(lambda[1]) * rnorm(1) / sqrt(m)
vec[(m / 2) + 1] = sqrt(lambda[(m / 2) + 1]) * rnorm(1) / sqrt(m)
i=sqrt(as.complex(-1))
for(j in 2:(m/2)){
uj = rnorm(1); vj = rnorm(1)
vec[j] = (sqrt(lambda[j]) * (uj + i * vj)) / (sqrt(2 * m))
vec[m + 2 - j] = (sqrt(lambda[j]) * (uj - i * vj)) / (sqrt(2 * m))
}
out[k, ] = Re(fft(vec))
}
out = out[, 1:N]
out = out + matrix(mu, n, N, byrow = T)
}
lambda
Sigma1 = matrix(c(1, 0.1, 0, 0, 0,
0.1, 1, 0.1, 0, 0,
0, 0.1, 1, 0.1, 0,
0, 0, 0.1, 1, 0.1,
0, 0, 0, 0.1, 1), 5, 5)
rmvToep(S5, igma1)
rmvToep(5, Sigma1)
test_that("rmvMat dimension", {
expect_equal(dim(rmvMat(30, c(0:50)/50, rho = 1, nu = 1)), c(30, 51))
expect_equal(dim(rmvMat(1, c(0:50)/50, rho = 1, nu = 1)), c(1, 51))
expect_equal(dim(rmvToep(50, Sigma1, mu = c(1, 2, 3, 4, 5))), c(50, 5))
})
#' @param Sigma covarinace matrix of the distribution. It should be a Toeplitz matrix
#' @param mu the mean vector of the distribtuion
#' @param symtol numerical threshold for checking symmetry in Sigma
#'
#' @return n by N (the number of rows in Sigma) matrix, n multivariate normal vectors stacked vertically
#' @export
#'
#' @examples
#' rmvToep(5, Sigma = diag(10), mu = rep(1, 10))
#' rmvToep(10, Sigma = diag(abs(rnorm(6))), mu = rep(1, 6))
rmvToep = function(n, Sigma, mu = rep(0, nrow(Sigma)), symtol = 1e-8){
N = dim(Sigma)[1]
if (dim(Sigma)[2] != N){
stop("Sigma should be a square matrix!")
}
if (max(abs(Sigma - t(Sigma))) > symtol){
stop("Sigma should be a symmetric matrix!")
}
# lambda = eigen(Sigma)$values
Sigma_vec = Sigma[1, ] # first row of Sigma, which contains all the values in Sigma
C_vec = c(Sigma_vec[1:N], Sigma_vec[N:1])
lambda = Re(fft(C_vec))
if (min(lambda) < 0){
stop("Sigma is ill-conditioned or not Positive definite; try rmvMat or rmvRBF if applicable.")
} else{
m = 2*N
out = matrix(0, n, m)
for (k in 1:n){
vec = rep(0, m)
vec[1] = sqrt(lambda[1]) * rnorm(1) / sqrt(m)
vec[(m / 2) + 1] = sqrt(lambda[(m / 2) + 1]) * rnorm(1) / sqrt(m)
i=sqrt(as.complex(-1))
for(j in 2:(m/2)){
uj = rnorm(1); vj = rnorm(1)
vec[j] = (sqrt(lambda[j]) * (uj + i * vj)) / (sqrt(2 * m))
vec[m + 2 - j] = (sqrt(lambda[j]) * (uj - i * vj)) / (sqrt(2 * m))
}
out[k, ] = Re(fft(vec))
}
out = out[, 1:N]
out = out + matrix(mu, n, N, byrow = T)
}
return(out)
}
test_that("Compatibility check", {
expect_error(rmvToep(5, Sigma2), "Sigma should be a square matrix!")
expect_error(rmvToep(5, Sigma3), "Sigma should be a symmetric matrix!")
expect_error(rmvToep(5, Sigma4), "Sigma is ill-conditioned or not Positive definite; try rmvMat or rmvRBF if applicable.")
expect_error(grid_regular_check(grid1), "gridpoints should be regular!")
})
#' @param Sigma covarinace matrix of the distribution. It should be a Toeplitz matrix
#' @param mu the mean vector of the distribtuion
#' @param symtol numerical threshold for checking symmetry in Sigma
#'
#' @return n by N (the number of rows in Sigma) matrix, n multivariate normal vectors stacked vertically
#' @export
#'
#' @examples
#' rmvToep(5, Sigma = diag(10), mu = rep(1, 10))
#' rmvToep(10, Sigma = diag(abs(rnorm(6))), mu = rep(1, 6))
rmvToep = function(n, Sigma, mu = rep(0, nrow(Sigma)), symtol = 1e-8){
N = dim(Sigma)[1]
if (dim(Sigma)[2] != N){
stop("Sigma should be a square matrix!")
}
if (max(abs(Sigma - t(Sigma))) > symtol){
stop("Sigma should be a symmetric matrix!")
}
# lambda = eigen(Sigma)$values
Sigma_vec = Sigma[1, ] # first row of Sigma, which contains all the values in Sigma
C_vec = c(Sigma_vec[1:N], Sigma_vec[N:1])
lambda = Re(fft(C_vec))
if (min(lambda) < 0){
stop("Sigma is ill-conditioned or not Positive definite; try rmvMat or rmvRBF if applicable.")
} else{
m = 2*N
out = matrix(0, n, m)
for (k in 1:n){
vec = rep(0, m)
vec[1] = sqrt(lambda[1]) * rnorm(1) / sqrt(m)
vec[(m / 2) + 1] = sqrt(lambda[(m / 2) + 1]) * rnorm(1) / sqrt(m)
i=sqrt(as.complex(-1))
for(j in 2:(m/2)){
uj = rnorm(1); vj = rnorm(1)
vec[j] = (sqrt(lambda[j]) * (uj + i * vj)) / (sqrt(2 * m))
vec[m + 2 - j] = (sqrt(lambda[j]) * (uj - i * vj)) / (sqrt(2 * m))
}
out[k, ] = Re(fft(vec))
}
out = out[, 1:N]
out = out + matrix(mu, n, N, byrow = T)
}
return(out)
}
Sigma2 = matrix(c(2, 1, 0,
1, 2, 1,
0, 1.001, 2,
1, 2, 3), 3, 4)
Sigma3 = matrix(c(2, 1, 0,
1, 2, 1,
0, 1.001, 2), 3, 3)
Sigma4 = matrix(c(1, 0.99, 0.97, 0.94, 0.89,
0.99, 1, 0.99, 0.97, 0.94,
0.97, 0.99, 1, 0.99, 0.97,
0.94, 0.97, 0.99, 1, 0.99,
0.89, 0.94, 0.97, 0.99, 1), 5, 5)
grid1 = c(0:8)/8
grid1[3] = grid1[3] + 0.001
test_that("Compatibility check", {
expect_error(rmvToep(5, Sigma2), "Sigma should be a square matrix!")
expect_error(rmvToep(5, Sigma3), "Sigma should be a symmetric matrix!")
expect_error(rmvToep(5, Sigma4), "Sigma is ill-conditioned or not Positive definite; try rmvMat or rmvRBF if applicable.")
expect_error(grid_regular_check(grid1), "gridpoints should be regular!")
})
rmvRBF(50, c(0:10), l = 0.1, mu = 10 * runif(10))
library(MVToep)
?MatK
?RBFK
AA = matrix(c(1.0, 0.7, 0.4, 0, 0, 0, 0,
0.7, 1.0, 0.7, 0.4, 0, 0, 0,
0.4, 0.7, 1.0, 0.7, 0.4, 0, 0,
0, 0.4, 0.7, 1.0, 0.7, 0.4, 0,
0, 0, 0.4, 0.7, 1.0, 0.7, 0.4,
0, 0, 0, 0.4, 0.7, 1.0, 0.7,
0, 0, 0, 0, 0.4, 0.7, 1.0), 7, 7)
max(abs(AA - t(AA))
)
rmvToep(100, AA)
Sigma = AA
N = 7
# lambda = eigen(Sigma)$values
Sigma_vec = Sigma[1, ] # first row of Sigma, which contains all the values in Sigma
C_vec = c(Sigma_vec[1:N], Sigma_vec[N:1])
lambda = Re(fft(C_vec))
lambda
AA = matrix(c(1.0, 0.7, 0.2, 0, 0, 0, 0,
0.7, 1.0, 0.7, 0.2, 0, 0, 0,
0.2, 0.7, 1.0, 0.7, 0.2, 0, 0,
0, 0.2, 0.7, 1.0, 0.7, 0.2, 0,
0, 0, 0.2, 0.7, 1.0, 0.7, 0.2,
0, 0, 0, 0.2, 0.7, 1.0, 0.7,
0, 0, 0, 0, 0.2, 0.7, 1.0), 7, 7)
rmvToep(100, AA)
Sigma = AA
N = 7
AA = matrix(c(1.0, 0.7, 0, 0, 0, 0, 0,
0.7, 1.0, 0.7, 0, 0, 0, 0,
0, 0.7, 1.0, 0.7, 0, 0, 0,
0, 0, 0.7, 1.0, 0.7, 0, 0,
0, 0, 0, 0.7, 1.0, 0.7, 0,
0, 0, 0, 0, 0.7, 1.0, 0.7,
0, 0, 0, 0, 0, 0.7, 1.0), 7, 7)
rmvToep(100, AA)
Sigma = AA
N = 7
# lambda = eigen(Sigma)$values
Sigma_vec = Sigma[1, ] # first row of Sigma, which contains all the values in Sigma
C_vec = c(Sigma_vec[1:N], Sigma_vec[N:1])
lambda = Re(fft(C_vec))
lambda
AA = matrix(c(1.0, 0.3, 0, 0, 0, 0, 0,
0.3, 1.0, 0.3, 0, 0, 0, 0,
0, 0.3, 1.0, 0.3, 0, 0, 0,
0, 0, 0.3, 1.0, 0.3, 0, 0,
0, 0, 0, 0.3, 1.0, 0.3, 0,
0, 0, 0, 0, 0.3, 1.0, 0.3,
0, 0, 0, 0, 0, 0.3, 1.0), 3, 3)
rmvToep(100, AA)
AA = matrix(c(1.0, 0.3, 0, 0, 0, 0, 0,
0.3, 1.0, 0.3, 0, 0, 0, 0,
0, 0.3, 1.0, 0.3, 0, 0, 0,
0, 0, 0.3, 1.0, 0.3, 0, 0,
0, 0, 0, 0.3, 1.0, 0.3, 0,
0, 0, 0, 0, 0.3, 1.0, 0.3,
0, 0, 0, 0, 0, 0.3, 1.0), 7, 7)
rmvToep(100, AA)
Sigma = AA
N = 7
C_vec = c(Sigma_vec[1:N], Sigma_vec[N:1])
lambda = Re(fft(C_vec))
min(lambda)
AA = matrix(c(1.0, 0.12, 0, 0, 0, 0, 0,
0.12, 1.0, 0.12, 0, 0, 0, 0,
0, 0.12, 1.0, 0.12, 0, 0, 0,
0, 0, 0.12, 1.0, 0.12, 0, 0,
0, 0, 0, 0.12, 1.0, 0.12, 0,
0, 0, 0, 0, 0.12, 1.0, 0.12,
0, 0, 0, 0, 0, 0.12, 1.0), 7, 7)
rmvToep(100, AA)
# lambda = eigen(Sigma)$values
Sigma_vec = Sigma[1, ] # first row of Sigma, which contains all the values in Sigma
C_vec = c(Sigma_vec[1:N], Sigma_vec[N:1])
lambda = Re(fft(C_vec))
min(lambda)
rmvToep(100, AA)
Sigma = AA
# lambda = eigen(Sigma)$values
Sigma_vec = Sigma[1, ] # first row of Sigma, which contains all the values in Sigma
C_vec = c(Sigma_vec[1:N], Sigma_vec[N:1])
lambda = Re(fft(C_vec))
min(lambda)
AA = matrix(c(5.0, 0.11, 0, 0, 0, 0, 0,
0.11, 5.0, 0.11, 0, 0, 0, 0,
0, 0.11, 5.0, 0.11, 0, 0, 0,
0, 0, 0.11, 5.0, 0.11, 0, 0,
0, 0, 0, 0.11, 5.0, 0.11, 0,
0, 0, 0, 0, 0.11, 5.0, 0.11,
0, 0, 0, 0, 0, 0.11, 5.0), 7, 7)
rmvToep(100, AA)
Sigma = AA
N = 7
# lambda = eigen(Sigma)$values
Sigma_vec = Sigma[1, ] # first row of Sigma, which contains all the values in Sigma
C_vec = c(Sigma_vec[1:N], Sigma_vec[N:1])
lambda = Re(fft(C_vec))
min(lambda)
AA = matrix(c(5.0, 1.2, 0, 0, 0, 0, 0,
1.2, 5.0, 1.2, 0, 0, 0, 0,
0, 1.2, 5.0, 1.2, 0, 0, 0,
0, 0, 1.2, 5.0, 1.2, 0, 0,
0, 0, 0, 1.2, 5.0, 1.2, 0,
0, 0, 0, 0, 1.2, 5.0, 1.2,
0, 0, 0, 0, 0, 1.2, 5.0), 7, 7)
rmvToep(100, AA)
Sigma = AA
N = 7
# lambda = eigen(Sigma)$values
Sigma_vec = Sigma[1, ] # first row of Sigma, which contains all the values in Sigma
C_vec = c(Sigma_vec[1:N], Sigma_vec[N:1])
lambda = Re(fft(C_vec))
min(lambda)
AA = matrix(c(5.0, 1.2, 0.3, 0, 0, 0, 0,
1.2, 5.0, 1.2, 0.3, 0, 0, 0,
0.3, 1.2, 5.0, 1.2, 0.3, 0, 0,
0, 0.3, 1.2, 5.0, 1.2, 0.3, 0,
0, 0, 0.3, 1.2, 5.0, 1.2, 0.3,
0, 0, 0, 0.3, 1.2, 5.0, 1.2,
0, 0, 0, 0, 0.3, 1.2, 5.0), 7, 7)
rmvToep(100, AA)
Sigma = AA
N = 7
# lambda = eigen(Sigma)$values
Sigma_vec = Sigma[1, ] # first row of Sigma, which contains all the values in Sigma
C_vec = c(Sigma_vec[1:N], Sigma_vec[N:1])
lambda = Re(fft(C_vec))
min(lambda)
AA = matrix(c(5.0, 3.5, 0.3, 0, 0, 0, 0,
3.5, 5.0, 3.5, 0.3, 0, 0, 0,
0.3, 3.5, 5.0, 3.5, 0.3, 0, 0,
0, 0.3, 3.5, 5.0, 3.5, 0.3, 0,
0, 0, 0.3, 3.5, 5.0, 3.5, 0.3,
0, 0, 0, 0.3, 3.5, 5.0, 3.5,
0, 0, 0, 0, 0.3, 3.5, 5.0), 7, 7)
rmvToep(100, AA)
Sigma = AA
lambda = Re(fft(C_vec))
# lambda = eigen(Sigma)$values
Sigma_vec = Sigma[1, ] # first row of Sigma, which contains all the values in Sigma
C_vec = c(Sigma_vec[1:N], Sigma_vec[N:1])
lambda = Re(fft(C_vec))
AA = matrix(c(5.0, 1.2, 1.2, 0, 0, 0, 0,
1.2, 5.0, 1.2, 1.2, 0, 0, 0,
1.2, 1.2, 5.0, 1.2, 1.2, 0, 0,
0, 1.2, 1.2, 5.0, 1.2, 1.2, 0,
0, 0, 1.2, 1.2, 5.0, 1.2, 1.2,
0, 0, 0, 1.2, 1.2, 5.0, 1.2,
0, 0, 0, 0, 1.2, 1.2, 5.0), 7, 7)
rmvToep(100, AA)
Sigma = AA
N = 7
C_vec = c(Sigma_vec[1:N], Sigma_vec[N:1])
lambda = Re(fft(C_vec))
# lambda = eigen(Sigma)$values
Sigma_vec = Sigma[1, ] # first row of Sigma, which contains all the values in Sigma
C_vec = c(Sigma_vec[1:N], Sigma_vec[N:1])
lambda = Re(fft(C_vec))
min(lambda)
min(Re(fft(5.0, 1.2, 1.2, 0, 0, 0, 0, 0, 0, 0, 0, 1.2, 1.2, 5.0)))
min(Re(fft(c(5.0, 1.2, 1.2, 0, 0, 0, 0, 0, 0, 0, 0, 1.2, 1.2, 5.0))))
min(Re(fft(c(5.0, 0.8, 0.8, 0, 0, 0, 0, 0, 0, 0, 0, 0.8, 0.8, 5.0))))
min(Re(fft(c(5.0, 1.5, 1.5, 0, 0, 0, 0, 0, 0, 0, 0, 1.5, 1.5, 5.0))))
aa = rep(1, 14)
aa[1] = aa[1] + 4
aa[14] = aa[14] + 4
min(Re(fft(aa)))
aa = rep(1, 14)
aa[1] = aa[1] + 3
aa[14] = aa[14] + 3
min(Re(fft(aa)))
min(Re(fft(c(5.0, 1.5, 1.5, 0, 0, 0, 0, 0, 0, 0, 0, 1.5, 1.5, 5.0))))
aa = rep(-1, 14)
aa[1] = aa[1] + 5
aa[14] = aa[14] + 5
min(Re(fft(aa)))
aa = rep(0.5, 14)
aa[1] = aa[1] + 5
aa[14] = aa[14] + 5
min(Re(fft(aa)))
AA = Sigma.AR.order(0.3, 20)
Sigma.AR.order = function(rho, p, order = NULL){
if (order = NULL){
AA = Sigma.AR.order(0.3, 20)
Sigma.AR.order = function(rho, p, order = p){
R = diag(p)
for(i in 1:p){
for(j in 1:p){
R[i, j] = ifelse(abs(i-j) > order, 0, rho^(abs(i-j)))
}
return(R)
}
AA = Sigma.AR.order(0.3, 20)
nnd.C.Toep(AA)
nnd.C.Toep = function(Sigma){
N = nrow(Sigma)
Sigma_vec = Sigma[1, ]
out = min(Re(fft(c(Sigma_vec[1:N], Sigma_vec[N:1]))))
return(ifelse(out >= 0, "rmvToep is applicable for the given Sigma!",
"min(lambda) < 0; rmvToep cannot be applied for the given Sigma!"))
}
nnd.C.Toep(AA)
floor(-2.5)
#' @param p The number of rows for the desired matrix to be returned
#' @param order The order of the AR model; default value is p
#'
#' @return It returns the p by p matrix with the element. For the return matrix C,
#' \eqn{C[i, j] = \rho^{|i-j|}} if \eqn{|i-j|<=order}, else 0
#' @export
#'
#' @examples
#' Sigma.AR.order(0.3, 20)
#' Sigma.AR.order(0.5, 10, order = 0)
Sigma.AR.order = function(rho, p, order = p){
order = floor(order)
if (order < 0){
stop("order should be given as a non-negative integer!")
}
R = diag(p)
for(i in 1:p){
for(j in 1:p){
R[i, j] = ifelse(abs(i-j) > order, 0, rho^(abs(i-j)))
}
return(R)
}
#' nonnegativity check for the given Toeplitz matrix
#'
#' @param Sigma A matrix to be checked
#'
#' @return It returns the inspection result of the matrix.
#' @export
#'
#' @examples
#' nnd.C.Toep(diag(3))
#' nnd.C.Toep(Sigma.AR.order(0.3, 20))
nnd.C.Toep = function(Sigma){
N = nrow(Sigma)
Sigma_vec = Sigma[1, ]
out = min(Re(fft(c(Sigma_vec[1:N], Sigma_vec[N:1]))))
return(ifelse(out >= 0, "rmvToep is applicable for the given Sigma!",
"min(lambda) < 0; rmvToep cannot be applied for the given Sigma!"))
}
Sigma1 = matrix(c(1, 0.1, 0, 0, 0,
0.1, 1, 0.1, 0, 0,
0, 0.1, 1, 0.1, 0,
0, 0, 0.1, 1, 0.1,
0, 0, 0, 0.1, 1), 5, 5)
test_that("rmv dimension test", {
expect_equal(dim(rmvToep(50, Sigma1, mu = c(1, 2, 3, 4, 5))), c(50, 5))
expect_equal(dim(rmvMat(30, c(0:50)/50, rho = 1, nu = 1)), c(30, 51))
expect_equal(dim(rmvMat(1, c(0:50)/50, rho = 1, nu = 1)), c(1, 51))
expect_equal(dim(rmvRBF(50, c(0:10), l = 0.1, mu = 10 * runif(10))), c(50, 11))
})
Sigma11 = Sigma.AR.order(0.3, 20)
Sigma12 = Sigma.AR.order(0.3, 20, order = 2)
test_that("rmvToep result test", {
expect_equal(dim(Sigma11, c(20, 20)))
expect_equal(nnd.C.Toep(Sigma11), "rmvToep is applicable for the given Sigma!")
expect_equal(nnd.C.Toep(Sigma12), "min(lambda) < 0; rmvToep cannot be applied for the given Sigma!")
})
test_that("rmvToep result test", {
expect_equal(dim(Sigma11), c(20, 20))
expect_equal(nnd.C.Toep(Sigma11), "rmvToep is applicable for the given Sigma!")
expect_equal(nnd.C.Toep(Sigma12), "min(lambda) < 0; rmvToep cannot be applied for the given Sigma!")
})
Sigma12 = Sigma.AR.order(0.3, 10, order = 2)
nnd.C.Toep(Sigma12)
Sigma12 = Sigma.AR.order(0.8, 10, order = 2)
nnd.C.Toep(Sigma12)
Sigma11 = Sigma.AR.order(0.3, 20)
Sigma12 = Sigma.AR.order(0.8, 10, order = 2)
test_that("rmvToep result test", {
expect_equal(dim(Sigma11), c(20, 20))
expect_equal(nnd.C.Toep(Sigma11), "rmvToep is applicable for the given Sigma!")
expect_equal(nnd.C.Toep(Sigma12), "min(lambda) < 0; rmvToep cannot be applied for the given Sigma!")
})
